#This app classifies News text into categories. Algorigthm used is Multinomial Naive Bayes
#Author Anubhav Lavania. Indiana University, Bloomington.

from flask import Flask,render_template,url_for,request
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer
from sklearn.naive_bayes import MultinomialNB
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import pickle
import json
import plotly

app = Flask(__name__)

@app.route("/")

def home():
    return render_template('index.html')

# Data cleanup task. Json file has a lot of information but we are only interested in short_description and category.
def process_data(json_filename, category, short_description):
    df = pd.read_json(json_filename, lines=True)  # Create pandas dataframe from json
    df = df[['category', 'short_description']] #Only need 2 colums of data
    df.columns = ['category', 'short_description']
    df = df[pd.notnull(df['short_description'])] #Remove null values if any
    df['category_id'] = df['category'].factorize()[0] # Crate numerical values column for categories.
    #category_id_df = df[['category', 'category_id']].drop_duplicates().sort_values('category_id')
    #category_to_id = dict(category_id_df.values)
    #id_to_category = dict(category_id_df[['category_id', 'category']].values)
    return df 

df = process_data('test_data.json', 'category', 'short_description')

X_train, X_test, y_train, y_test = train_test_split(df['short_description'], df['category'], random_state = 0) # Split the data into test and train
count_vect = CountVectorizer() 
X_train_counts = count_vect.fit_transform(X_train) # Convert words to numbers and assign values as per the importance of words. 
tfidf_transformer = TfidfTransformer( )             #for example word politics is more important in classification than mine.
X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts) # Fit and transform.
clf_nb = MultinomialNB().fit(X_train_tfidf, y_train)
#clf_lr = LogisticRegression(random_state=0).fit(X_train_tfidf, y_train)
#clf_rf = RandomForestClassifier(n_estimators=200, max_depth=3, random_state=0).fit(X_train_tfidf, y_train)


y_predicted = clf_nb.predict(X_train_tfidf)  # To calculate confusion matrix.
conf_mat = confusion_matrix(y_train, y_predicted)
#sns.heatmap(conf_mat, annot=True)
#plt.show()

def output(classifier, vectoriser, text_in_list_toCheck):  # Save the model to be used for classification.
    pickle.dump(classifier, open('model.pkl', 'wb'))
    pickle.dump(vectoriser, open('tfidfvect.pkl', 'wb'))
    pkld_model = pickle.load(open('model.pkl', 'rb'))
    pkld_vect = pickle.load(open('tfidfvect.pkl', 'rb'))
    return  pkld_model.predict(pkld_vect.transform(text_in_list_toCheck))

#text_to_check = ["Hi this is a good day to have politics and party"]
#print(output(clf_rf, count_vect, text_to_check))

def bar_chart(data):  # Crate Bar chart of classification.
    d = data.groupby('category').count().reset_index()
    dfbar = d.rename(columns={"category":"category"})
    fig = px.bar(dfbar, x='category', y='short_description')
    return fig

@app.route('/result',methods=['POST'])  # /results holds the prediction for text input by user in text box.
def results():
    if request.method == 'POST':
        message = request.form['message']
        data = [message]
        myprediction = output(clf_nb, count_vect, data)
    return render_template('result.html', prediction = myprediction)

@app.route("/dashboard")  #/dashboard holds bar chart generated by plotly.
def dashboard():
    graphJSON = json.dumps(bar_chart(df), cls=plotly.utils.PlotlyJSONEncoder)
    return render_template('nodash.html', graphJSON=graphJSON)


if __name__ == '__main__':
	app.run(debug=True)